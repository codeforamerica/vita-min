#!/usr/bin/env bash

##
# this script pushes current origin/main onto the release branch
# and creates a release using GitHub's `hub` tool

# bash strict mode
set -euo pipefail

# check for dependencies
if [ ! $(which gh) ]; then
  echo "looks like you don't have gh installed! try:"
  echo "brew install gh"
  echo "gh auth login"
  echo ""
  echo "then try again"
  exit 1
fi

# capture origin's given name
origin_git_remote=$(git remote -v | grep 'github.com:codeforamerica/vita-min' | head -n1 | awk '{ print $1 }')

# get the latest tags and branches
echo "Fetching from ${origin_git_remote}"
git fetch "$origin_git_remote" --quiet

# get the old and new commit IDs
current_release="$(git rev-parse "$origin_git_remote"/release)"
current_main="$(git rev-parse "$origin_git_remote"/main)"

# show the user a list of commits that will be deployed
echo "ðŸš€ Will push ${current_main} to release, initiating a production deployment."
GIT_PAGER= git log --pretty="format:* %s" ${current_release}...${current_main}

# ask the user for the new tag name/version number, accepting the default if
# nothing is entered.
latest_version="$(git tag --list | grep 'version-' | sort --version-sort | tail -n1)"
guessed_next_version="$(echo "$latest_version" | awk -F. -v OFS=. '{ ++$NF; print; }')"
echo ""
echo "Most recent version tag: ${latest_version}"
echo -n "New tag name (e.g. '$guessed_next_version'): "
read new_tag
new_tag=${new_tag:-$guessed_next_version}

tmpdir="$(mktemp -d -t release-notes)"
tmpfile="${tmpdir}/${new_tag}-release-notes.txt"

cat <<TEMPLATE > $tmpfile
$(date +%Y-%m-%d) RELEASE TITLE

$(git log --pretty="format:- %s" ${current_release}...${current_main})

<!--
Note: everything within the HTML comment block won't be displayed.

Describe the release--include high-level changes, _markdown accepted_

* #123123123 - story/feature description
* short description of change
* another change
-->
TEMPLATE

# want a different editor? set your EDITOR in your shell's rc file
if which mine > /dev/null; then
  DEFAULT_EDITOR="mine --wait"
else
  DEFAULT_EDITOR="vim"
fi
EDITOR="${EDITOR:-${DEFAULT_EDITOR}}"
$EDITOR "$tmpfile"

echo "Updating local release branch to origin/main (${current_main})"
git checkout release
git merge --ff "${current_main}"
# if an error occurs here, bail out.
if [ ! $? ] ; then
  # merge failed
  echo "unable to merge via fast-forward. likely conflict."
  echo "try: \`git merge -ff main\` and resolve conflicts."
  exit 1
fi

echo "Pushing origin/main (${current_main}) to release branch on GitHub. This triggers deployment."
git push "$origin_git_remote" "${current_main}":release

echo "Creating new release tag $new_tag from $tmpfile"
gh release create -F "$tmpfile" "$new_tag" > /dev/null

# All done!
echo ""
echo "âœ¨ Released https://github.com/codeforamerica/vita-min/releases/tag/$new_tag !"
echo "ðŸ§· If needed, rollback to: ${current_release}"
echo ""
echo "â€¢ Watch deployment on CircleCI: https://app.circleci.com/pipelines/github/codeforamerica/vita-min?branch=release"

# Allow the cleanup function to switch to the user's original branch.
