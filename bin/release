#!/usr/bin/env bash

##
# this script pushes current origin/main onto the release branch
# and creates a release using GitHub's `hub` tool

# bash strict mode
set -euo pipefail

# check for dependencies
if [ ! "$(which gh > /dev/null)" ]; then
  echo "It looks like you don't have gh installed. Try:"
  echo ""
  echo "brew install gh"
  echo "gh auth login"
  echo ""
  echo "After that, run this script again."
  exit 1
fi

# capture origin's given name
origin_git_remote="$(git remote -v | grep 'github.com:codeforamerica/vita-min' | head -n1 | awk '{ print $1 }')"

# get the latest tags and branches
echo "Fetching from ${origin_git_remote}"
git fetch "$origin_git_remote" --quiet

# get the old and new commit IDs
current_release="$(git rev-parse "$origin_git_remote"/release)"
current_main="$(git rev-parse "$origin_git_remote"/main)"

# show the user a list of commits that will be deployed
echo "ðŸš€ Preparing to release origin/main (${current_main}).  Ctrl-C to cancel. These commits will be included:"
tmpdir="$(mktemp -d -t release-notes)"
commits_file="$tmpdir/commits.txt"
git --no-pager log --pretty="format:* %s" "${current_release}...${current_main}" > "$commits_file"
cat "$commits_file"

# ask the user for the new tag name/version number, accepting the default if
# nothing is entered.
latest_version="$(git tag --list | grep 'version-' | sort --version-sort | tail -n1)"
guessed_next_version="$(echo "$latest_version" | awk -F. -v OFS=. '{ ++$NF; print; }')"
echo ""
echo "Most recent version tag: ${latest_version}"
echo -n "New tag name (e.g. '$guessed_next_version'): "
read -r new_tag
new_tag=${new_tag:-$guessed_next_version}

release_notes_file="${tmpdir}/${new_tag}-release-notes.txt"

cat <<TEMPLATE > "$release_notes_file"
$(date +%Y-%m-%d) RELEASE TITLE

$(cat "$commits_file")

<!--
These release notes will be provided to #gyr-team and should explain
user-visible changes for non-engineers.

Note: everything within the HTML comment block won't be displayed.

* #123123123 - story/feature description
* short description of change
* another change
-->
TEMPLATE

# want a different editor? set your EDITOR in your shell's rc file
if which mine > /dev/null; then
  DEFAULT_EDITOR="mine --wait"
else
  DEFAULT_EDITOR="vim"
fi
EDITOR="${EDITOR:-${DEFAULT_EDITOR}}"
"$EDITOR" "$release_notes_file"

echo "Updating local release branch."
git checkout release
git merge --ff-only "${current_main}" || {
  # merge failed
  echo "unable to merge via fast-forward. likely conflict."
  echo "try: \`git merge -ff main\` and resolve conflicts."
  exit 1
}

echo "Updating release branch on GitHub. This triggers deployment."
git push "$origin_git_remote" "${current_main}":release
echo ""
echo "â€¢ Released! Watch deployment on CircleCI: https://app.circleci.com/pipelines/github/codeforamerica/vita-min?branch=release"
echo ""

echo "Creating new release tag $new_tag from $release_notes_file"
gh release create -F "$release_notes_file" "$new_tag" > /dev/null

# All done!
echo ""
echo "âœ¨ Released https://github.com/codeforamerica/vita-min/releases/tag/$new_tag !"
echo "ðŸ§· If needed, rollback to: ${current_release}"

# Remove tempfiles now that they are successfully uploaded.
rm -f "$release_notes_file" "$commits_file"
rmdir "$tmpdir"

# Allow the cleanup function to switch back to the user's original branch.
